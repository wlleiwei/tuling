# MySQL索引结构

## 1.  索引定义

索引是帮助MySQL存储引擎快速获取数据的**排好序**的**数据结构**。

## 2. 索引数据结构

Innodb是将一个表中的数据存储到磁盘的存储引擎，因为数据保存在磁盘上，所以关机之后也不会丢失数据。对于表数据真正的处理过程发生在内存中，所以需要把要操作的数据从磁盘加载到内存中，对于数据的更改或者写入操作也要同步到磁盘中。但是磁盘的读写相比于内存操作非常耗时，innodb为了平衡磁盘与内存的读写速度，将保存在磁盘的数据分为若干页，磁盘与内存的交互以页为单位，**每页默认大小为16KB**。 

每个数据页存储表的行记录，行记录按照主键值的大小按照从小到大的顺序构成一个单链表，而且在每个页会维护一个页目录，在数据页中搜索数据时可以采用二分法查找。除此之外，**每个数据页之间组成了一个双向链表**。

**补充：**严格来说，每页中的行记录是进行分组存储的，页目录只是记录分组的地址，页内查找时，首先通过二分法确定分组的位置，然后遍历分组找到数据。

下面开始说明索引的数据结构

- **哈希索引**

  根据索引列计算哈希值，在哈希表中记录指向该记录的指针。哈希索引只适用于等值查询，可以根据检索条件快速定位到数据行，如果进行范围查找的话，需要进行全表扫描，无法使用索引。

- **二叉排序树**

  数据库中的数据需要持久化到磁盘中，因此树中的每个节点代表磁盘上的一条记录，这些节点可能不是连续存储，可能会分散到磁盘的各个角落。在进行查找时，有两条弊端：

  1. 树的查找效率取决于树的高度，当表中的数据过多时，树会变得很高，进而会导致查找效率低下；
  2. 在查找的过程中需要将磁盘中的节点加载到内存中，由于数据可能不是连续存储，会产生大量的随机IO，浪费大量时间。

- **B+树**

  B+树是innodb存储引擎的的索引结构。所有的数据均保存在叶子节点中，非叶子节点仅保存索引列和指向下一层的指针（优点：**非叶子节点代表的数据页可以存储更多的索引数据，相同的树高会保存更多的数据**），所有的叶子节点通过双向链表链接起来，**便于在查找时进行范围查找**。

## 3. 聚簇索引

1. 使用主键值进行记录和页的排序
   - 页内的记录是根据主键值大小顺序排成一个单链表；
   - 数据页也是根据主键值大小组织成一个双向链表；
2. B+树的叶子节点保存完整的记录，数据和索引在同一个文件中。

我们把具有这两种特性的B+树称为**聚簇索引，所有的完整记录都保存在叶子节点处**。Innodb会自动根据主键值创建聚簇索引，*若没有声明主键，会自动选取表中唯一非空列作为主键，若找不到会自动创建一个隐藏的row_id列作为主键*。

**为何选取自增整型作为主键？**

1. 整型：数据间的判断大小规则简单，速度快，占空间小；字符串判断大小规则复杂，速度慢，占空间大；
2. 自增：这和B+树的数据插入有关。B+树叶子节点数据页内部需要按照主键值按照从小到大的顺序进行排序，并且页内数据是顺序存储的，在进行数据插入时，首先要找到数据插入位置（哪个数据页、数据页中什么位置），然后插入数据。
   - 自增：主键都是排好序的，可以直接接在上一条记录的后面，无须移动任何记录。如果页内数据页记录数达到最大，则会申请一个新的数据页空间进行存储，不涉及到B+树的页分裂。
   - 非自增：主键无序的时候，首先定位到插入到哪个数据页中，根据数据页中的数据分为两种情况，页内数据未满、页内数据已经存满
     - **页内数据未满：**比较主键值的大小确定插入位置，如果插在中间位置，则需要将该外置以后的所有数据向后挪，腾出空间给新插入的数据，挪数据必然要消耗额外的时间。
     - **页内数据已经存满：**定位到需要插入中间位置，由于数据页没有空间可以插入新数据，此时需要进行B+树的页分裂，将原本一个页的数据放在两个数据页存储，并且涉及到三个数据页的改动，将新数据插入到合适位置上，这会非常耗时，并且会占用更多的存储空间。除此之外，页分裂（数据删除）会产生内部碎片，会导致一部分页内空间得不到利用。**在数据删除时，页内的空间没有立即释放，会对该记录做一个删除标记，页面内会维护一个删除记录组成的垃圾链表，这些记录占用的空间称为可重新空间，之后有新记录插入时就会覆盖这些空间**。可采用OPTIMIZE TABLE来优化碎片问题，但是这涉及到索引的重构，会消耗大量的时间，需要谨慎操作。

## 4. 二级索引

不同于聚簇索引，二级索引是为非主键列建立的索引，页内记录和数据页之间根据索引列进行排序，B+树的叶子节点并不保存完整数据，仅保存索引列和主键值。

**为何只保存主键值，不保存其他列数据？**

1. 节省存储空间；
2. 保证数据的一致性：对于数据的修改只需要更改聚簇索引即可（主键一般不改动），如果二级索引叶子节点也保存完整的数据，数据更新时需要对所有的索引进行更新，从而保证数据一致性，相比于只修改聚簇索引耗时多。

## 5. 覆盖索引

如果一个索引包含查询所需要的所有列，我们就称之为覆盖索引。尤其对于二级索引来说，效率更高，因为叶子节点仅保存索引列和主键值，此时不需要根据主键值再回进行回表操作（**回表操作可以看所是随机IO操作**）效率更高。

## 6. MyISAM存储引擎索引

与Innodb不同，MyISAM的数据文件和索引文件是分开存放的，即MyISAM中没有聚簇索引。MyISAM索引将表中的数据按照**插入顺序**保存在一个文件中，称之为数据文件。该文件并不进行分页，而是记录表中所有的数据，**每条数据都对应一个行号，而且每行是定长的，因此我们可以通过行号快速定位一条记录**（如果不是定长，则存储在数据文件中的地址偏移量），类似于下面表格所示。

|        行号         | col1 | col2 | ...  |
| :-----------------: | :--: | :--: | :--: |
| 1（或者地址偏移量） |  10  |  10  | ...  |
| 2（或者地址偏移量） |  20  |  20  | ...  |
|         ...         | ...  | ...  | ...  |

由于插入数据的时候没有按照主键排序，而是按照数据插入表的顺序记录，因此不能使用二分法查找数据，那MyIASM是如何进行高效的查找呢？

MyIASM会单独为主键根据B+树创建一个索引，只不过叶子节点存储的是主键值+行号（地址偏移量），不是完整的记录，索引会单独保存在一个索引文件中，在查找记录时，先查找到记录对应的行号，然后根据行号去数据文件中取数据，这和Innodb的二级索引十分相似，这意味着在MyIASM中创建的索引都是二级索引，在查找数据时都需要进行回表操作。

**Innodb和MyIASM存储引擎的区别？**

1. Innodb的主键索引，叶子节点存储的是完整的记录，这就导致innodb的聚簇索引数据和索引都在一颗B+树中，即Innodb的数据文件和索引文件是在一起的；MyIASM的主键索引叶子节点存储的是主键值+记录的行号，即MyIASM的数据文件和索引文件是分开的。
2. 根据主键进行查找时，因为Innodb叶子节点保存完整的记录，可以直接在叶子节点获取数据，不需要回表；MyIASM叶子节点仅保存记录的行号，根据主键值获取到记录的行号后，需要到数据文件中根据行号获取完整的记录，即需要进行回表操作。
3. 其余待后续补充......

## 7. 根据索引进行数据查找

1. Innodb

   - 主键索引
      -	根据主键索引主键值定位到对应的叶子节点数据页
      -	将数据页加载到内存中，根据数据页中的页目录进行二分查找，获取到完整的记录

   - 二级索引
     - 根据索引列找到对应的二级索引的叶子结点，然后获取叶子节点中对应的主键值
     - 根据主键值去主键索引的查找完整的记录，参考根据主键索引查找数据

   **注意：**

   **回表：**在根据二级索引查找数据时，由于二级索引叶子结点未保存完整的记录，仅保存主键值，要想获取除索引列和主键列的其他数据列，需要根据主键值去主键索引中查询（主键索引中保存完整的记录），这个过程叫做回表。回表的过程可以看做是随机IO操作，如果出现大量数据需要回表，会产生大量的随机IO，可能比全表扫描更耗费时间，此时mysql不会走索引，会采取全表扫描的方式。

   **索引下推：**在MySQL5.6以前，在对二级索引进行查找时，首先根据索引列去查找对应的主键值，再根据主键值去主键索引中查出所需要的列，然后根据where语句中的条件进行筛选数据。自5.6以后，mysql采取了新的方式：在对二级索引进行查找时，先对二级索引树中包含的字段进行判断，过滤掉不符合条件的数据，从而减少回表的次数，提高查询效率。

2. MyIASM

   由于MyIASM的索引文件和数据文件是分开的，所以主键索引和二级索引的查找过程是一致的：

   根据索引列条件和索引找到对应的叶子节点，叶子节点保存的是索引列+行号（地址偏移量），然后根据行号去数据文件中找对应的记录。

   由于MyIASM存储的是行号，即记录在数据文件中的位置，我们可以直接拿到数据，这个回表过程是很快的。而innodb二级索引查到的是主键值，在进行回表时还要根据主键索引查找，这个回表过程没有MyIASM的回表速度快。





